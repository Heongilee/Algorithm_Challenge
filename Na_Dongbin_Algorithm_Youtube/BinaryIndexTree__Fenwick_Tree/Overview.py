'''
# 비트 0이 아닌 K의 가장 마지막 비트 수를 찾는 방법
# 
# ->>           K & -K 연산을 취한다.
# 
# i) K = 1
# 0000 0000 0000 0001
# 1111 1111 1111 1111
#-----------------------
# 0000 0000 0000 0001           result is 1
#
# ii) K = 2
# 0000 0000 0000 0010
# 1111 1111 1111 1110
#---------------------
# 0000 0000 0000 0010           result is 2
#
# iii) K = 3
# 0000 0000 0000 0011
# 1111 1111 1111 1101
#---------------------
# 0000 0000 0000 0001           result is 1
#
# iv) K = 8
#
# 0000 0000 0000 1000
# 1111 1111 1111 1000
#---------------------
# 0000 0000 0000 1000           result is 8
'''

'''
===== 결과 출력 ==========
0 의 마지막 비트: 0
1 의 마지막 비트: 1
2 의 마지막 비트: 2
3 의 마지막 비트: 1
4 의 마지막 비트: 4
5 의 마지막 비트: 1
6 의 마지막 비트: 2             
7 의 마지막 비트: 1              
8 의 마지막 비트: 8          
9 의 마지막 비트: 1          
10 의 마지막 비트: 2
11 의 마지막 비트: 1
12 의 마지막 비트: 4
13 의 마지막 비트: 1
14 의 마지막 비트: 2
15 의 마지막 비트: 1
16 의 마지막 비트: 16
'''
#n = 16
#for i in range(n + 1):
#    print(i, "의 마지막 비트:", i & -i)

################################################################################################
# Solution.
###########################################################################################
# i번째 수 까지의 누적합을 구하는 함수
def prefixSummation(i):
    res = 0
    while i > 0:
        res += tree[i]
        i -= (i & -i)
    return res

# i번째 수를 diff만큼 업데이트 하는 함수
def update(i, diff):
    while i <= n:
        tree[i] += diff
        i += (i & -i)

# 구간합을 구하는 함수
def intervalSummation(start, end):
    return prefixSummation(end) - prefixSummation(start - 1)

if __name__ == '__main__':
    n, m, k = map(int, input().split())

    arr = [0] * (n + 1)
    tree = [0] * (n + 1)

    for i in range(1, n + 1):
        x = int(input())
        arr[i] = x
        update(i, x)
    
    for i in range(m + k):
        a, b, c = map(int, input().split())
        if a == 1:
            update(b, c - arr[b])   # 바뀐 크기(diff)만큼 적용
            arr[b] = c
        else:
            print(intervalSummation(b, c))